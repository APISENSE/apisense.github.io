[{"!define":{"battery":{"isConnector":{"!type":"fn(connector: num) -> bool","!doc":"\nTells if the current connector correspond to the asked connector.\n\n@param connector The connector to check.\n@return true if connectors matches, false otherwise.\n\n"},"connector":{"!type":"fn() -> str","!doc":"\nReturn the current connector of the battery.\n\n@return The battery connector.\n\n"},"level":{"!type":"fn() -> num","!doc":"\nReturn the current level of the battery.\n\n@return The battery level.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the battery.\n\n@return The battery state.\n\n"},"technology":{"!type":"fn() -> str","!doc":"\nReturn the current technology of the battery.\n\n@return The battery technology.\n\n"},"temperature":{"!type":"fn() -> num","!doc":"\nReturn the current temperature of the battery.\n\n@return The battery temperature.\n\n"},"voltage":{"!type":"fn() -> num","!doc":"\nReturn the current voltage of the battery.\n\n@return The battery voltage.\n\n"},"onLevelChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a levelChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user battery.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('battery').\n\n"},"AC":{"!type":"num","!doc":"\nConstant representing the AC Connector of the battery.\n\n"},"USB":{"!type":"num","!doc":"\nConstant representing the USB Connector of the battery.\n\n"},"WIRELESS":{"!type":"num","!doc":"\nConstant representing the WIRELESS Connector of the battery.\n\n"},"NOT_CONNECTED":{"!type":"num","!doc":"\nConstant representing the NOT_CONNECTED Connector of the battery.\n\n"},"FULL":{"!type":"num","!doc":"\nConstant representing the FULL State of the battery.\n\n"},"CHARGING":{"!type":"num","!doc":"\nConstant representing the CHARGING State of the battery.\n\n"},"DISCHARGING":{"!type":"num","!doc":"\nConstant representing the DISCHARGING State of the battery.\n\n"}},"form":{"results":{"!type":"fn() -> JSON","!doc":"\nReturn the current results of the form.\n\n@return The form results.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user form.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"onResult":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the form dart detects a result.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"multiPage":{"!type":"fn() -> MultiPageForm","!doc":"\nCreates a new, fully customizable, form\n\n"},"singlePage":{"!type":"fn(title: str) -> SinglePageForm","!doc":"\nCreates a single form contained on a unique page\n\n@param title Title of the form to generate\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('form').\n\n"}},"location":{"accuracy":{"!type":"fn() -> num","!doc":"\nReturn the current accuracy of the location.\n\n@return The location accuracy.\n\n"},"altitude":{"!type":"fn() -> num","!doc":"\nReturn the current altitude of the location.\n\n@return The location altitude.\n\n"},"bearing":{"!type":"fn() -> num","!doc":"\nReturn the current bearing of the location.\n\n@return The location bearing.\n\n"},"latitude":{"!type":"fn() -> num","!doc":"\nReturn the current latitude of the location.\n\n@return The location latitude.\n\n"},"longitude":{"!type":"fn() -> num","!doc":"\nReturn the current longitude of the location.\n\n@return The location longitude.\n\n"},"isMode":{"!type":"fn(mode: num) -> bool","!doc":"\nTells if the current mode correspond to the asked mode.\n\n@param mode The mode to check.\n@return true if modes matches, false otherwise.\n\n"},"mode":{"!type":"fn() -> str","!doc":"\nReturn the current mode of the location.\n\n@return The location mode.\n\n"},"isSource":{"!type":"fn(source: num) -> bool","!doc":"\nTells if the current source correspond to the asked source.\n\n@param source The source to check.\n@return true if sources matches, false otherwise.\n\n"},"source":{"!type":"fn() -> str","!doc":"\nReturn the current source of the location.\n\n@return The location source.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the location.\n\n@return The location speed.\n\n"},"onLocationChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the location dart detects a locationChanged.\nProvided that the filters matches with the filters.\n\n@param filter The location configuration to set, can contain:\n- mode (LocationMode): The GPS \"mode\" (PASSIVE by default),\n- distance (Double): The minimal distance in meters between two triggered locations (50 meters by default),\n- period (String): The maximal period of time between two triggered locations, using Time syntax (e.g. '5 min').\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user location.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('location').\n\n"},"ACTIVE":{"!type":"num","!doc":"\nConstant representing the ACTIVE Mode of the location.\n\n"},"PASSIVE":{"!type":"num","!doc":"\nConstant representing the PASSIVE Mode of the location.\n\n"},"GPS":{"!type":"num","!doc":"\nConstant representing the GPS Source of the location.\n\n"},"NETWORK":{"!type":"num","!doc":"\nConstant representing the NETWORK Source of the location.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Source of the location.\n\n"}},"log":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user log.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"debug":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the debug level.\n\n@param message The message to print.\n\n"},"error":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the error level.\n\n@param message The message to print.\n\n"},"info":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the info level.\n\n@param message The message to print.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('log').\n\n"}},"recorder":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user recorder.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"save":{"!type":"fn(data: fn(JSON)) -> Void","!doc":"\nSave the data locally, waiting to be synchronised.\n\n@param data The json element to save.\n\n"},"sync":{"!type":"fn(header: JSON) -> Void","!doc":"\nCall the synchronisation with the honeycomb sever of the previously saved records, with a custom header.\n\n@param header Json element to add once to the exported data.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('recorder').\n\n"}},"timer":{"every":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a every.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"at":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a at.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"once":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a once.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user timer.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('timer').\n\n"}},"wifi":{"isAuthentication":{"!type":"fn(authentication: num) -> bool","!doc":"\nTells if the current authentication correspond to the asked authentication.\n\n@param authentication The authentication to check.\n@return true if authentications matches, false otherwise.\n\n"},"authentication":{"!type":"fn() -> str","!doc":"\nReturn the current authentication of the wifi.\n\n@return The wifi authentication.\n\n"},"bssid":{"!type":"fn() -> str","!doc":"\nReturn the current bssid of the wifi.\n\n@return The wifi bssid.\n\n"},"frequency":{"!type":"fn() -> num","!doc":"\nReturn the current frequency of the wifi.\n\n@return The wifi frequency.\n\n"},"rssi":{"!type":"fn() -> num","!doc":"\nReturn the current rssi of the wifi.\n\n@return The wifi rssi.\n\n"},"ssid":{"!type":"fn() -> str","!doc":"\nReturn the current ssid of the wifi.\n\n@return The wifi ssid.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the wifi.\n\n@return The wifi state.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onSsidChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a ssidChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScanCompleted":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a scanCompleted.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user wifi.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('wifi').\n\n"},"WEP":{"!type":"num","!doc":"\nConstant representing the WEP Authentication of the wifi.\n\n"},"WPA_PSK":{"!type":"num","!doc":"\nConstant representing the WPA_PSK Authentication of the wifi.\n\n"},"CONNECTED":{"!type":"num","!doc":"\nConstant representing the CONNECTED State of the wifi.\n\n"},"DISCONNECTED":{"!type":"num","!doc":"\nConstant representing the DISCONNECTED State of the wifi.\n\n"}}},"_sting_definitions":{"_battery":{"!type":"battery"},"_form":{"!type":"form"},"_location":{"!type":"location"},"_log":{"!type":"log"},"_recorder":{"!type":"recorder"},"_timer":{"!type":"timer"},"_wifi":{"!type":"wifi"}},"!name":"APISENSELib"},{"!define":{"apm":{"url":{"!type":"fn() -> str","!doc":"\nReturn the current url of the apm.\n\n@return The apm url.\n\n"},"ping":{"!type":"fn() -> num","!doc":"\nReturn the current ping of the apm.\n\n@return The apm ping.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the current ttl of the apm.\n\n@return The apm ttl.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the current traceroute of the apm.\n\n@return The apm traceroute.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the apm.\n\n@return The apm speed.\n\n"},"size":{"!type":"fn() -> num","!doc":"\nReturn the current size of the apm.\n\n@return The apm size.\n\n"},"time":{"!type":"fn() -> num","!doc":"\nReturn the current time of the apm.\n\n@return The apm time.\n\n"},"onScanCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a scanCompleted.\nProvided that the filters matches with the filters.\n\n@param url The url configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onDownloadCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a downloadCompleted.\nProvided that the filters matches with the filters.\n\n@param url The url configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUploadCompleted":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a uploadCompleted.\nProvided that the filters matches with the filters.\n\n@param filter The apm configuration to set, can contain:\n- url (String): The 'url' to contact,\n- protocol (String): The 'protocol' to use (FTP{,s}),\n- username (String): The 'username' if any,\n- password (String): The 'password' if any,\n- size (Integer): The 'size' of the file to upload.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user apm.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('apm').\n\n"}},"networkAnalysis":{"isNetworkType":{"!type":"fn(networkType: num) -> bool","!doc":"\nTells if the current networkType correspond to the asked networkType.\n\n@param networkType The networkType to check.\n@return true if networkTypes matches, false otherwise.\n\n"},"networkType":{"!type":"fn() -> str","!doc":"\nReturn the current networkType of the networkAnalysis.\n\n@return The networkAnalysis networkType.\n\n"},"error":{"!type":"fn() -> str","!doc":"\nReturn the current error of the networkAnalysis.\n\n@return The networkAnalysis error.\n\n"},"task":{"!type":"fn() -> str","!doc":"\nReturn the current task of the networkAnalysis.\n\n@return The networkAnalysis task.\n\n"},"ip":{"!type":"fn() -> str","!doc":"\nReturn the current ip of the networkAnalysis.\n\n@return The networkAnalysis ip.\n\n"},"duration":{"!type":"fn() -> num","!doc":"\nReturn the current duration of the networkAnalysis.\n\n@return The networkAnalysis duration.\n\n"},"hostname":{"!type":"fn() -> str","!doc":"\nReturn the current hostname of the networkAnalysis.\n\n@return The networkAnalysis hostname.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the current ttl of the networkAnalysis.\n\n@return The networkAnalysis ttl.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the current traceroute of the networkAnalysis.\n\n@return The networkAnalysis traceroute.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the networkAnalysis.\n\n@return The networkAnalysis speed.\n\n"},"speeds":{"!type":"fn() -> Arr","!doc":"\nReturn the current speeds of the networkAnalysis.\n\n@return The networkAnalysis speeds.\n\n"},"size":{"!type":"fn() -> num","!doc":"\nReturn the current size of the networkAnalysis.\n\n@return The networkAnalysis size.\n\n"},"records":{"!type":"fn() -> Arr","!doc":"\nReturn the current records of the networkAnalysis.\n\n@return The networkAnalysis records.\n\n"},"packetCount":{"!type":"fn() -> num","!doc":"\nReturn the current packetCount of the networkAnalysis.\n\n@return The networkAnalysis packetCount.\n\n"},"outOfOrderRatio":{"!type":"fn() -> num","!doc":"\nReturn the current outOfOrderRatio of the networkAnalysis.\n\n@return The networkAnalysis outOfOrderRatio.\n\n"},"lossRatio":{"!type":"fn() -> num","!doc":"\nReturn the current lossRatio of the networkAnalysis.\n\n@return The networkAnalysis lossRatio.\n\n"},"jitter":{"!type":"fn() -> num","!doc":"\nReturn the current jitter of the networkAnalysis.\n\n@return The networkAnalysis jitter.\n\n"},"onTcpUpload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a tcpUpload.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- volume (Integer): The data volume to upload in megabytes,\n- size (Integer): The size of each packet to send in bytes,\n- period (Float): The sample period in seconds,\n- slowStart (Float): The slow start period that will be ignored in results in seconds.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onTcpDownload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a tcpDownload.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- volume (Integer): The data volume to download in megabytes,\n- size (Integer): The size of each packet to send in bytes,\n- period (Float): The sample period in seconds,\n- slowStart (Float): The slow start period that will be ignored in results in seconds.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUdpDownload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a udpDownload.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- size (Integer): [Mandatory] The size of each packet to send in bytes,\n- cycle (Integer): [Mandatory] The number of burst to send,\n- count (Integer): The number of packet to send by burst,\n- interval (Float): Time interval between each burst in milliseconds.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUdpUpload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a udpUpload.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- size (Integer): [Mandatory] The size of each packet to send in bytes,\n- cycle (Integer): [Mandatory] The number of burst to send,\n- count (Integer): The number of packet to send by burst,\n- interval (Float): Time interval between each burst in milliseconds.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onDnsRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a dnsRequest.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- target (String): [Mandatory] The domain to query,\n- server (String): The DNS server to query, will use the phone one if nothing is configured,\n- type (String): The type of DNS request,\n- class (String): The class of DNS request.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onPingRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a pingRequest.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- target (String): [Mandatory] The server to ping,\n- ttl (Integer): The maximum TTL.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onTracerouteRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the networkAnalysis dart detects a tracerouteRequest.\nProvided that the filters matches with the filters.\n\n@param filter The networkAnalysis configuration to set, can contain:\n- target (String): [Mandatory] The server to ping,\n- ttl (Integer): The maximum TTL.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user networkAnalysis.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('networkAnalysis').\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN NetworkType of the networkAnalysis.\n\n"},"NONE":{"!type":"num","!doc":"\nConstant representing the NONE NetworkType of the networkAnalysis.\n\n"},"WIFI":{"!type":"num","!doc":"\nConstant representing the WIFI NetworkType of the networkAnalysis.\n\n"},"ETHERNET":{"!type":"num","!doc":"\nConstant representing the ETHERNET NetworkType of the networkAnalysis.\n\n"},"BLUETOOTH":{"!type":"num","!doc":"\nConstant representing the BLUETOOTH NetworkType of the networkAnalysis.\n\n"},"MOB_UNKNOWN":{"!type":"num","!doc":"\nConstant representing the MOB_UNKNOWN NetworkType of the networkAnalysis.\n\n"},"MOB_2G":{"!type":"num","!doc":"\nConstant representing the MOB_2G NetworkType of the networkAnalysis.\n\n"},"MOB_3G":{"!type":"num","!doc":"\nConstant representing the MOB_3G NetworkType of the networkAnalysis.\n\n"},"MOB_4G":{"!type":"num","!doc":"\nConstant representing the MOB_4G NetworkType of the networkAnalysis.\n\n"}}},"_sting_definitions":{"_apm":{"!type":"apm"},"_networkAnalysis":{"!type":"networkAnalysis"}},"!name":"APISENSE-Network"},{"!define":{"call":{"duration":{"!type":"fn() -> num","!doc":"\nReturn the current duration of the call.\n\n@return The call duration.\n\n"},"contact":{"!type":"fn() -> str","!doc":"\nReturn the current contact of the call.\n\n@return The call contact.\n\n"},"carrier":{"!type":"fn() -> str","!doc":"\nReturn the current carrier of the call.\n\n@return The call carrier.\n\n"},"neighbouringCells":{"!type":"fn() -> Arr","!doc":"\nReturn the current neighbouringCells of the call.\n\n@return The call neighbouringCells.\n\n"},"onCallEnded":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the call dart detects a callEnded.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user call.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('call').\n\n"}},"device":{"manufacturer":{"!type":"fn() -> str","!doc":"\nReturn the current manufacturer of the device.\n\n@return The device manufacturer.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the device.\n\n@return The device model.\n\n"},"os":{"!type":"fn() -> str","!doc":"\nReturn the current os of the device.\n\n@return The device os.\n\n"},"version":{"!type":"fn() -> str","!doc":"\nReturn the current version of the device.\n\n@return The device version.\n\n"},"screenSize":{"!type":"fn() -> num","!doc":"\nReturn the current screenSize of the device.\n\n@return The device screenSize.\n\n"},"resolution":{"!type":"fn() -> str","!doc":"\nReturn the current resolution of the device.\n\n@return The device resolution.\n\n"},"rotation":{"!type":"fn() -> num","!doc":"\nReturn the current rotation of the device.\n\n@return The device rotation.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user device.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('device').\n\n"}},"localStorage":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user localStorage.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"store":{"!type":"fn(toSave: JSON) -> num","!doc":"\nSave the given json in a local database.\n\n@param toSave A Json object to save.\n\n"},"entries":{"!type":"fn() -> str","!doc":"\nRetrieve every store object. This method returns the raw string representing a JSON Array, you may want to parse it with 'JSON.parse'\n\n"},"retrieve":{"!type":"fn(identifier: num) -> str","!doc":"\nRetrieve an object from the ID returned by the 'store' method. This method returns the raw string representing a JSON Object, you may want to parse it with 'JSON.parse'\n\n@param identifier ID of the entry to retrieve.\n\n"},"drop":{"!type":"fn() -> Void","!doc":"\nClear the store.\n\n"},"remove":{"!type":"fn(identifier: num) -> Void","!doc":"\nRemove an object from the ID returned by the 'store' method.\n\n@param identifier ID of the entry to remove.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('localStorage').\n\n"}},"system":{"foreground":{"!type":"fn() -> str","!doc":"\nReturn the current foreground of the system.\n\n@return The system foreground.\n\n"},"services":{"!type":"fn() -> Arr","!doc":"\nReturn the current services of the system.\n\n@return The system services.\n\n"},"isScreen":{"!type":"fn(screen: num) -> bool","!doc":"\nTells if the current screen correspond to the asked screen.\n\n@param screen The screen to check.\n@return true if screens matches, false otherwise.\n\n"},"screen":{"!type":"fn() -> str","!doc":"\nReturn the current screen of the system.\n\n@return The system screen.\n\n"},"isLock":{"!type":"fn(lock: num) -> bool","!doc":"\nTells if the current lock correspond to the asked lock.\n\n@param lock The lock to check.\n@return true if locks matches, false otherwise.\n\n"},"lock":{"!type":"fn() -> str","!doc":"\nReturn the current lock of the system.\n\n@return The system lock.\n\n"},"onScreenUnlocked":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a screenUnlocked.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScreenStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a screenStateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onForegroundAppChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a foregroundAppChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user system.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('system').\n\n"},"ON":{"!type":"num","!doc":"\nConstant representing the ON Screen of the system.\n\n"},"OFF":{"!type":"num","!doc":"\nConstant representing the OFF Screen of the system.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Screen of the system.\n\n"},"LOCKED":{"!type":"num","!doc":"\nConstant representing the LOCKED Lock of the system.\n\n"},"UNLOCKED":{"!type":"num","!doc":"\nConstant representing the UNLOCKED Lock of the system.\n\n"},"NOT_SECURED":{"!type":"num","!doc":"\nConstant representing the NOT_SECURED Lock of the system.\n\n"}}},"_sting_definitions":{"_call":{"!type":"call"},"_device":{"!type":"device"},"_localStorage":{"!type":"localStorage"},"_system":{"!type":"system"}},"!name":"APISENSE-Phone"}]