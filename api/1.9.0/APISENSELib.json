{"!define":{"battery":{"isConnector":{"!type":"fn(connector: num) -> bool","!doc":"\nTells if the current connector correspond to the asked connector.\n\n@param connector The connector to check.\n@return true if connectors matches, false otherwise.\n\n"},"connector":{"!type":"fn() -> str","!doc":"\nReturn the current connector of the battery.\n\n@return The battery connector.\n\n"},"level":{"!type":"fn() -> num","!doc":"\nReturn the current level of the battery.\n\n@return The battery level.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the battery.\n\n@return The battery state.\n\n"},"technology":{"!type":"fn() -> str","!doc":"\nReturn the current technology of the battery.\n\n@return The battery technology.\n\n"},"temperature":{"!type":"fn() -> num","!doc":"\nReturn the current temperature of the battery.\n\n@return The battery temperature.\n\n"},"voltage":{"!type":"fn() -> num","!doc":"\nReturn the current voltage of the battery.\n\n@return The battery voltage.\n\n"},"onLevelChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a levelChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user battery.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('battery').\n\n"},"AC":{"!type":"num","!doc":"\nConstant representing the AC Connector of the battery.\n\n"},"USB":{"!type":"num","!doc":"\nConstant representing the USB Connector of the battery.\n\n"},"WIRELESS":{"!type":"num","!doc":"\nConstant representing the WIRELESS Connector of the battery.\n\n"},"NOT_CONNECTED":{"!type":"num","!doc":"\nConstant representing the NOT_CONNECTED Connector of the battery.\n\n"},"FULL":{"!type":"num","!doc":"\nConstant representing the FULL State of the battery.\n\n"},"CHARGING":{"!type":"num","!doc":"\nConstant representing the CHARGING State of the battery.\n\n"},"DISCHARGING":{"!type":"num","!doc":"\nConstant representing the DISCHARGING State of the battery.\n\n"}},"form":{"results":{"!type":"fn() -> JSON","!doc":"\nReturn the current results of the form.\n\n@return The form results.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user form.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"onResult":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the form dart detects a result.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"multiPage":{"!type":"fn() -> MultiPageForm","!doc":"\nCreates a new, fully customizable, form\n\n"},"singlePage":{"!type":"fn(title: str) -> SinglePageForm","!doc":"\nCreates a single form contained on a unique page\n\n@param title Title of the form to generate\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('form').\n\n"}},"location":{"accuracy":{"!type":"fn() -> num","!doc":"\nReturn the current accuracy of the location.\n\n@return The location accuracy.\n\n"},"altitude":{"!type":"fn() -> num","!doc":"\nReturn the current altitude of the location.\n\n@return The location altitude.\n\n"},"bearing":{"!type":"fn() -> num","!doc":"\nReturn the current bearing of the location.\n\n@return The location bearing.\n\n"},"latitude":{"!type":"fn() -> num","!doc":"\nReturn the current latitude of the location.\n\n@return The location latitude.\n\n"},"longitude":{"!type":"fn() -> num","!doc":"\nReturn the current longitude of the location.\n\n@return The location longitude.\n\n"},"isMode":{"!type":"fn(mode: num) -> bool","!doc":"\nTells if the current mode correspond to the asked mode.\n\n@param mode The mode to check.\n@return true if modes matches, false otherwise.\n\n"},"mode":{"!type":"fn() -> str","!doc":"\nReturn the current mode of the location.\n\n@return The location mode.\n\n"},"isSource":{"!type":"fn(source: num) -> bool","!doc":"\nTells if the current source correspond to the asked source.\n\n@param source The source to check.\n@return true if sources matches, false otherwise.\n\n"},"source":{"!type":"fn() -> str","!doc":"\nReturn the current source of the location.\n\n@return The location source.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the location.\n\n@return The location speed.\n\n"},"onLocationChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the location dart detects a locationChanged.\nProvided that the filters matches with the filters.\n\n@param filter The location configuration to set, can contain:\n- mode (LocationMode): The GPS \"mode\" (PASSIVE by default),\n- distance (Double): The minimal distance in meters between two triggered locations (50 meters by default),\n- period (String): The maximal period of time between two triggered locations, using Time syntax (e.g. '5 min').\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user location.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('location').\n\n"},"ACTIVE":{"!type":"num","!doc":"\nConstant representing the ACTIVE Mode of the location.\n\n"},"PASSIVE":{"!type":"num","!doc":"\nConstant representing the PASSIVE Mode of the location.\n\n"},"GPS":{"!type":"num","!doc":"\nConstant representing the GPS Source of the location.\n\n"},"NETWORK":{"!type":"num","!doc":"\nConstant representing the NETWORK Source of the location.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Source of the location.\n\n"}},"log":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user log.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"debug":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the debug level.\n\n@param message The message to print.\n\n"},"error":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the error level.\n\n@param message The message to print.\n\n"},"info":{"!type":"fn(message: str) -> Void","!doc":"\nPrint with the info level.\n\n@param message The message to print.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('log').\n\n"}},"recorder":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user recorder.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"save":{"!type":"fn(data: fn(JSON)) -> Void","!doc":"\nSave the data locally, waiting to be synchronised.\n\n@param data The json element to save.\n\n"},"sync":{"!type":"fn(header: JSON) -> Void","!doc":"\nCall the synchronisation with the honeycomb sever of the previously saved records, with a custom header.\n\n@param header Json element to add once to the exported data.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('recorder').\n\n"}},"timer":{"every":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a every.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"at":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a at.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"once":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a once.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user timer.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('timer').\n\n"}},"wifi":{"isAuthentication":{"!type":"fn(authentication: num) -> bool","!doc":"\nTells if the current authentication correspond to the asked authentication.\n\n@param authentication The authentication to check.\n@return true if authentications matches, false otherwise.\n\n"},"authentication":{"!type":"fn() -> str","!doc":"\nReturn the current authentication of the wifi.\n\n@return The wifi authentication.\n\n"},"bssid":{"!type":"fn() -> str","!doc":"\nReturn the current bssid of the wifi.\n\n@return The wifi bssid.\n\n"},"frequency":{"!type":"fn() -> num","!doc":"\nReturn the current frequency of the wifi.\n\n@return The wifi frequency.\n\n"},"rssi":{"!type":"fn() -> num","!doc":"\nReturn the current rssi of the wifi.\n\n@return The wifi rssi.\n\n"},"ssid":{"!type":"fn() -> str","!doc":"\nReturn the current ssid of the wifi.\n\n@return The wifi ssid.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the wifi.\n\n@return The wifi state.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onSsidChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a ssidChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScanCompleted":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a scanCompleted.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user wifi.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('wifi').\n\n"},"WEP":{"!type":"num","!doc":"\nConstant representing the WEP Authentication of the wifi.\n\n"},"WPA_PSK":{"!type":"num","!doc":"\nConstant representing the WPA_PSK Authentication of the wifi.\n\n"},"CONNECTED":{"!type":"num","!doc":"\nConstant representing the CONNECTED State of the wifi.\n\n"},"DISCONNECTED":{"!type":"num","!doc":"\nConstant representing the DISCONNECTED State of the wifi.\n\n"}}},"_sting_definitions":{"_battery":{"!type":"battery"},"_form":{"!type":"form"},"_location":{"!type":"location"},"_log":{"!type":"log"},"_recorder":{"!type":"recorder"},"_timer":{"!type":"timer"},"_wifi":{"!type":"wifi"}},"!name":"APISENSELib"}