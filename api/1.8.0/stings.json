{"!define":{"apm":{"!doc":"\nRetrieve data about the user apm.\n\n","onDownloadCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a downloadCompleted.\nProvided that the filters matches with the filters.\n\n@param url The url configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScanCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a scanCompleted.\nProvided that the filters matches with the filters.\n\n@param url The url configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUploadCompleted":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a uploadCompleted.\nProvided that the filters matches with the filters.\n\n@param filter The apm configuration to set, can contain:\n- The 'url' to contact,\n- The 'protocol' to use (FTP{,s}),\n- The 'username' if any,\n- The 'password' if any,\n- The 'size' of the file to upload.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"size":{"!type":"fn() -> num","!doc":"\nReturn the current size of the apm.\n\n@return The apm size.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the apm.\n\n@return The apm speed.\n\n"},"time":{"!type":"fn() -> num","!doc":"\nReturn the current time of the apm.\n\n@return The apm time.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the current ttl of the apm.\n\n@return The apm ttl.\n\n"},"ping":{"!type":"fn() -> num","!doc":"\nReturn the current ping of the apm.\n\n@return The apm ping.\n\n"},"url":{"!type":"fn() -> str","!doc":"\nReturn the current url of the apm.\n\n@return The apm url.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the current traceroute of the apm.\n\n@return The apm traceroute.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('apm').\n\n"}},"battery":{"!doc":"\nRetrieve data about the user battery.\n\n","isConnector":{"!type":"fn(connector: num) -> bool","!doc":"\nTells if the current connector correspond to the asked connector.\n\n@param connector The connector to check.\n@return true if connectors matches, false otherwise.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"onLevelChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a levelChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"level":{"!type":"fn() -> num","!doc":"\nReturn the current level of the battery.\n\n@return The battery level.\n\n"},"temperature":{"!type":"fn() -> num","!doc":"\nReturn the current temperature of the battery.\n\n@return The battery temperature.\n\n"},"voltage":{"!type":"fn() -> num","!doc":"\nReturn the current voltage of the battery.\n\n@return The battery voltage.\n\n"},"connector":{"!type":"fn() -> str","!doc":"\nReturn the current connector of the battery.\n\n@return The battery connector.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the battery.\n\n@return The battery state.\n\n"},"technology":{"!type":"fn() -> str","!doc":"\nReturn the current technology of the battery.\n\n@return The battery technology.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('battery').\n\n"},"AC":{"!type":"num","!doc":"\nConstant representing the AC Connector of the battery.\n\n"},"USB":{"!type":"num","!doc":"\nConstant representing the USB Connector of the battery.\n\n"},"WIRELESS":{"!type":"num","!doc":"\nConstant representing the WIRELESS Connector of the battery.\n\n"},"NOT_CONNECTED":{"!type":"num","!doc":"\nConstant representing the NOT_CONNECTED Connector of the battery.\n\n"},"FULL":{"!type":"num","!doc":"\nConstant representing the FULL State of the battery.\n\n"},"CHARGING":{"!type":"num","!doc":"\nConstant representing the CHARGING State of the battery.\n\n"},"DISCHARGING":{"!type":"num","!doc":"\nConstant representing the DISCHARGING State of the battery.\n\n"}},"form":{"!doc":"\nRetrieve data about the user form.\n\n","multiPage":{"!type":"fn() -> MultiPageForm","!doc":"\nCreates a new, fully customizable, form\n\n"},"singlePage":{"!type":"fn(title: str) -> SinglePageForm","!doc":"\nCreates a single form contained on a unique page\n\n@param title Title of the form to generate\n\n"},"onResult":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the form dart detects a result.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"results":{"!type":"fn() -> JSON","!doc":"\nReturn the current results of the form.\n\n@return The form results.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('form').\n\n"}},"location":{"!doc":"\nRetrieve data about the user location.\n\n","isMode":{"!type":"fn(mode: num) -> bool","!doc":"\nTells if the current mode correspond to the asked mode.\n\n@param mode The mode to check.\n@return true if modes matches, false otherwise.\n\n"},"isSource":{"!type":"fn(source: num) -> bool","!doc":"\nTells if the current source correspond to the asked source.\n\n@param source The source to check.\n@return true if sources matches, false otherwise.\n\n"},"onLocationChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the location dart detects a locationChanged.\nProvided that the filters matches with the filters.\n\n@param filter The location configuration to set, can contain:\n- The GPS \"mode\" (PASSIVE by default),\n- The minimal distance in meters between two triggered locations (50 meters by default),\n- The maximal period of time between two triggered locations, using Time syntax (e.g. '5 min').\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"accuracy":{"!type":"fn() -> num","!doc":"\nReturn the current accuracy of the location.\n\n@return The location accuracy.\n\n"},"altitude":{"!type":"fn() -> num","!doc":"\nReturn the current altitude of the location.\n\n@return The location altitude.\n\n"},"bearing":{"!type":"fn() -> num","!doc":"\nReturn the current bearing of the location.\n\n@return The location bearing.\n\n"},"latitude":{"!type":"fn() -> num","!doc":"\nReturn the current latitude of the location.\n\n@return The location latitude.\n\n"},"longitude":{"!type":"fn() -> num","!doc":"\nReturn the current longitude of the location.\n\n@return The location longitude.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the location.\n\n@return The location speed.\n\n"},"mode":{"!type":"fn() -> str","!doc":"\nReturn the current mode of the location.\n\n@return The location mode.\n\n"},"source":{"!type":"fn() -> str","!doc":"\nReturn the current source of the location.\n\n@return The location source.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('location').\n\n"},"ACTIVE":{"!type":"num","!doc":"\nConstant representing the ACTIVE Mode of the location.\n\n"},"PASSIVE":{"!type":"num","!doc":"\nConstant representing the PASSIVE Mode of the location.\n\n"},"GPS":{"!type":"num","!doc":"\nConstant representing the GPS Source of the location.\n\n"},"NETWORK":{"!type":"num","!doc":"\nConstant representing the NETWORK Source of the location.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Source of the location.\n\n"}},"timer":{"!doc":"\nRetrieve data about the user timer.\n\n","at":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a at.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"every":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a every.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"once":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a once.\nProvided that the filters matches with the filters.\n\n@param time The time configuration to set, can contain:\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('timer').\n\n"}},"wifi":{"!doc":"\nRetrieve data about the user wifi.\n\n","isAuthentication":{"!type":"fn(authentication: num) -> bool","!doc":"\nTells if the current authentication correspond to the asked authentication.\n\n@param authentication The authentication to check.\n@return true if authentications matches, false otherwise.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"onScanCompleted":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a scanCompleted.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onSsidChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a ssidChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"frequency":{"!type":"fn() -> num","!doc":"\nReturn the current frequency of the wifi.\n\n@return The wifi frequency.\n\n"},"rssi":{"!type":"fn() -> num","!doc":"\nReturn the current rssi of the wifi.\n\n@return The wifi rssi.\n\n"},"authentication":{"!type":"fn() -> str","!doc":"\nReturn the current authentication of the wifi.\n\n@return The wifi authentication.\n\n"},"bssid":{"!type":"fn() -> str","!doc":"\nReturn the current bssid of the wifi.\n\n@return The wifi bssid.\n\n"},"ssid":{"!type":"fn() -> str","!doc":"\nReturn the current ssid of the wifi.\n\n@return The wifi ssid.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the wifi.\n\n@return The wifi state.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('wifi').\n\n"},"WEP":{"!type":"num","!doc":"\nConstant representing the WEP Authentication of the wifi.\n\n"},"WPA_PSK":{"!type":"num","!doc":"\nConstant representing the WPA_PSK Authentication of the wifi.\n\n"},"CONNECTED":{"!type":"num","!doc":"\nConstant representing the CONNECTED State of the wifi.\n\n"},"DISCONNECTED":{"!type":"num","!doc":"\nConstant representing the DISCONNECTED State of the wifi.\n\n"}}},"_sting_definitions":{"_apm":{"!type":"apm"},"_battery":{"!type":"battery"},"_form":{"!type":"form"},"_location":{"!type":"location"},"_timer":{"!type":"timer"},"_wifi":{"!type":"wifi"}},"!name":"APISENSELib"}