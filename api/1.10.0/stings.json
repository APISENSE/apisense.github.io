[{"!define":{"apm":{"url":{"!type":"fn() -> str","!doc":"\nReturn the current url of the apm.\n\n@return The apm url.\n\n"},"ping":{"!type":"fn() -> num","!doc":"\nReturn the current ping of the apm.\n\n@return The apm ping.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the current ttl of the apm.\n\n@return The apm ttl.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the current traceroute of the apm.\n\n@return The apm traceroute.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the apm.\n\n@return The apm speed.\n\n"},"size":{"!type":"fn() -> num","!doc":"\nReturn the current size of the apm.\n\n@return The apm size.\n\n"},"time":{"!type":"fn() -> num","!doc":"\nReturn the current time of the apm.\n\n@return The apm time.\n\n"},"onScanCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a scanCompleted.\nProvided that the filters matches with the filters.\n\n@param url The 'url' to contact.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onDownloadCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a downloadCompleted.\nProvided that the filters matches with the filters.\n\n@param url The url to access.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUploadCompleted":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the apm dart detects a uploadCompleted.\nProvided that the filters matches with the filters.\n\n@param filter The apm configuration to set, can contain:\n- url (String): The 'url' to contact,\n- protocol (String): The 'protocol' to use (FTP{,s}),\n- username (String): The 'username' if any,\n- password (String): The 'password' if any,\n- size (Integer): The 'size' of the file to upload.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user apm.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('apm').\n\n"}},"networkAnalysis":{"isNetworkType":{"!type":"fn(networkType: num) -> bool","!doc":"\nTells if the current networkType correspond to the asked networkType.\n\n@param networkType The networkType to check.\n@return true if networkTypes matches, false otherwise.\n\n"},"networkType":{"!type":"fn() -> str","!doc":"\nReturn the current networkType of the networkAnalysis.\n\n@return The networkAnalysis networkType.\n\n"},"error":{"!type":"fn() -> str","!doc":"\nReturn the current error of the networkAnalysis.\n\n@return The networkAnalysis error.\n\n"},"task":{"!type":"fn() -> str","!doc":"\nReturn the current task of the networkAnalysis.\n\n@return The networkAnalysis task.\n\n"},"ip":{"!type":"fn() -> str","!doc":"\nReturn the current ip of the networkAnalysis.\n\n@return The networkAnalysis ip.\n\n"},"duration":{"!type":"fn() -> num","!doc":"\nReturn the current duration of the networkAnalysis.\n\n@return The networkAnalysis duration.\n\n"},"hostname":{"!type":"fn() -> str","!doc":"\nReturn the current hostname of the networkAnalysis.\n\n@return The networkAnalysis hostname.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the current ttl of the networkAnalysis.\n\n@return The networkAnalysis ttl.\n\n"},"rtt":{"!type":"fn() -> Rtt","!doc":"\nReturn the current rtt of the networkAnalysis.\n\n@return The networkAnalysis rtt.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the current traceroute of the networkAnalysis.\n\n@return The networkAnalysis traceroute.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the networkAnalysis.\n\n@return The networkAnalysis speed.\n\n"},"speeds":{"!type":"fn() -> Arr","!doc":"\nReturn the current speeds of the networkAnalysis.\n\n@return The networkAnalysis speeds.\n\n"},"size":{"!type":"fn() -> num","!doc":"\nReturn the current size of the networkAnalysis.\n\n@return The networkAnalysis size.\n\n"},"records":{"!type":"fn() -> Arr","!doc":"\nReturn the current records of the networkAnalysis.\n\n@return The networkAnalysis records.\n\n"},"packetCount":{"!type":"fn() -> num","!doc":"\nReturn the current packetCount of the networkAnalysis.\n\n@return The networkAnalysis packetCount.\n\n"},"outOfOrderRatio":{"!type":"fn() -> num","!doc":"\nReturn the current outOfOrderRatio of the networkAnalysis.\n\n@return The networkAnalysis outOfOrderRatio.\n\n"},"lossRatio":{"!type":"fn() -> num","!doc":"\nReturn the current lossRatio of the networkAnalysis.\n\n@return The networkAnalysis lossRatio.\n\n"},"jitter":{"!type":"fn() -> num","!doc":"\nReturn the current jitter of the networkAnalysis.\n\n@return The networkAnalysis jitter.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user networkAnalysis.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"onDnsRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nSend a DNS request and report the results\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onPingRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nSend a ping request and report the results\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onTcpDownload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nDownload the required data size and report network statistics\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onTcpUpload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nUpload the required data size and report network statistics\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onTracerouteRequest":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nSend a traceroute request and report the results\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onUdpDownload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nSend the required number of packets and report network statistics\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"onUdpUpload":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> JSPromise","!doc":"\nSend the required number of packets and report network statistics\n\n@param filter filters to apply\n@param callback onDone callback\n\n"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('networkAnalysis').\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN NetworkType of the networkAnalysis.\n\n"},"NONE":{"!type":"num","!doc":"\nConstant representing the NONE NetworkType of the networkAnalysis.\n\n"},"WIFI":{"!type":"num","!doc":"\nConstant representing the WIFI NetworkType of the networkAnalysis.\n\n"},"ETHERNET":{"!type":"num","!doc":"\nConstant representing the ETHERNET NetworkType of the networkAnalysis.\n\n"},"BLUETOOTH":{"!type":"num","!doc":"\nConstant representing the BLUETOOTH NetworkType of the networkAnalysis.\n\n"},"MOB_UNKNOWN":{"!type":"num","!doc":"\nConstant representing the MOB_UNKNOWN NetworkType of the networkAnalysis.\n\n"},"MOB_2G":{"!type":"num","!doc":"\nConstant representing the MOB_2G NetworkType of the networkAnalysis.\n\n"},"MOB_3G":{"!type":"num","!doc":"\nConstant representing the MOB_3G NetworkType of the networkAnalysis.\n\n"},"MOB_4G":{"!type":"num","!doc":"\nConstant representing the MOB_4G NetworkType of the networkAnalysis.\n\n"}}},"_sting_definitions":{"_apm":{"!type":"apm"},"_networkAnalysis":{"!type":"networkAnalysis"}},"!name":"APISENSE-Network"},{"!define":{"battery":{"isConnector":{"!type":"fn(connector: num) -> bool","!doc":"\nTells if the current connector correspond to the asked connector.\n\n@param connector The connector to check.\n@return true if connectors matches, false otherwise.\n\n"},"connector":{"!type":"fn() -> str","!doc":"\nReturn the current connector of the battery.\n\n@return The battery connector.\n\n"},"level":{"!type":"fn() -> num","!doc":"\nReturn the current level of the battery.\n\n@return The battery level.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the battery.\n\n@return The battery state.\n\n"},"technology":{"!type":"fn() -> str","!doc":"\nReturn the current technology of the battery.\n\n@return The battery technology.\n\n"},"temperature":{"!type":"fn() -> num","!doc":"\nReturn the current temperature of the battery.\n\n@return The battery temperature.\n\n"},"voltage":{"!type":"fn() -> num","!doc":"\nReturn the current voltage of the battery.\n\n@return The battery voltage.\n\n"},"onLevelChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a levelChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user battery.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('battery').\n\n"},"AC":{"!type":"num","!doc":"\nConstant representing the AC Connector of the battery.\n\n"},"USB":{"!type":"num","!doc":"\nConstant representing the USB Connector of the battery.\n\n"},"WIRELESS":{"!type":"num","!doc":"\nConstant representing the WIRELESS Connector of the battery.\n\n"},"NOT_CONNECTED":{"!type":"num","!doc":"\nConstant representing the NOT_CONNECTED Connector of the battery.\n\n"},"FULL":{"!type":"num","!doc":"\nConstant representing the FULL State of the battery.\n\n"},"CHARGING":{"!type":"num","!doc":"\nConstant representing the CHARGING State of the battery.\n\n"},"DISCHARGING":{"!type":"num","!doc":"\nConstant representing the DISCHARGING State of the battery.\n\n"}},"form":{"results":{"!type":"fn() -> JSON","!doc":"\nReturn the current results of the form.\n\n@return The form results.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user form.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"onResult":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the form dart detects a result.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"multiPage":{"!type":"fn() -> MultiPageForm","!doc":"\nCreates a new, fully customizable, form\n\n@return A form creation tool enabling to create multiple pages\n\n"},"singlePage":{"!type":"fn(title: str) -> SinglePageForm","!doc":"\nCreates a single form contained on a unique page\n\n@param title Title of the form to generate\n@return A simple form creation tool\n\n"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('form').\n\n"}},"location":{"accuracy":{"!type":"fn() -> num","!doc":"\nReturn the current accuracy of the location.\n\n@return The location accuracy.\n\n"},"altitude":{"!type":"fn() -> num","!doc":"\nReturn the current altitude of the location.\n\n@return The location altitude.\n\n"},"bearing":{"!type":"fn() -> num","!doc":"\nReturn the current bearing of the location.\n\n@return The location bearing.\n\n"},"latitude":{"!type":"fn() -> num","!doc":"\nReturn the current latitude of the location.\n\n@return The location latitude.\n\n"},"longitude":{"!type":"fn() -> num","!doc":"\nReturn the current longitude of the location.\n\n@return The location longitude.\n\n"},"isMode":{"!type":"fn(mode: num) -> bool","!doc":"\nTells if the current mode correspond to the asked mode.\n\n@param mode The mode to check.\n@return true if modes matches, false otherwise.\n\n"},"mode":{"!type":"fn() -> str","!doc":"\nReturn the current mode of the location.\n\n@return The location mode.\n\n"},"isSource":{"!type":"fn(source: num) -> bool","!doc":"\nTells if the current source correspond to the asked source.\n\n@param source The source to check.\n@return true if sources matches, false otherwise.\n\n"},"source":{"!type":"fn() -> str","!doc":"\nReturn the current source of the location.\n\n@return The location source.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the current speed of the location.\n\n@return The location speed.\n\n"},"onLocationChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the location dart detects a locationChanged.\nProvided that the filters matches with the filters.\n\n@param filter The location configuration to set, can contain:\n- mode (LocationMode): The GPS \"mode\" (PASSIVE by default),\n- distance (Double): The minimal distance in meters between two triggered locations (50 meters by default),\n- period (String): The maximal period of time between two triggered locations, using Time syntax (e.g. '5 min').\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user location.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('location').\n\n"},"ACTIVE":{"!type":"num","!doc":"\nConstant representing the ACTIVE Mode of the location.\n\n"},"PASSIVE":{"!type":"num","!doc":"\nConstant representing the PASSIVE Mode of the location.\n\n"},"GPS":{"!type":"num","!doc":"\nConstant representing the GPS Source of the location.\n\n"},"NETWORK":{"!type":"num","!doc":"\nConstant representing the NETWORK Source of the location.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Source of the location.\n\n"}},"log":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user log.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"debug":{"!type":"fn(message: str)","!doc":"\nPrint with the debug level.\n\n@param message The message to print.\n\n"},"error":{"!type":"fn(message: str)","!doc":"\nPrint with the error level.\n\n@param message The message to print.\n\n"},"info":{"!type":"fn(message: str)","!doc":"\nPrint with the info level.\n\n@param message The message to print.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('log').\n\n"}},"recorder":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user recorder.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"save":{"!type":"fn(data: fn(JSON))","!doc":"\nSave the data locally, waiting to be synchronised.\n\n@param data The json element to save.\n\n"},"sync":{"!type":"fn(header: JSON)","!doc":"\nCall the synchronisation with the honeycomb sever of the previously saved records, with a custom header.\n\n@param header Json element to add once to the exported data.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('recorder').\n\n"}},"timer":{"every":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a every.\nProvided that the filters matches with the filters.\n\n@param time The time to wait between each event call (e.g. \"10h\").\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"at":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a at.\nProvided that the filters matches with the filters.\n\n@param time The time at which the event must be triggered each day.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"once":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the timer dart detects a once.\nProvided that the filters matches with the filters.\n\n@param time The time at which the event must be triggered each day.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user timer.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('timer').\n\n"}},"wifi":{"isAuthentication":{"!type":"fn(authentication: num) -> bool","!doc":"\nTells if the current authentication correspond to the asked authentication.\n\n@param authentication The authentication to check.\n@return true if authentications matches, false otherwise.\n\n"},"authentication":{"!type":"fn() -> str","!doc":"\nReturn the current authentication of the wifi.\n\n@return The wifi authentication.\n\n"},"bssid":{"!type":"fn() -> str","!doc":"\nReturn the current bssid of the wifi.\n\n@return The wifi bssid.\n\n"},"frequency":{"!type":"fn() -> num","!doc":"\nReturn the current frequency of the wifi.\n\n@return The wifi frequency.\n\n"},"rssi":{"!type":"fn() -> num","!doc":"\nReturn the current rssi of the wifi.\n\n@return The wifi rssi.\n\n"},"ssid":{"!type":"fn() -> str","!doc":"\nReturn the current ssid of the wifi.\n\n@return The wifi ssid.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the wifi.\n\n@return The wifi state.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a stateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onSsidChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a ssidChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScanCompleted":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the wifi dart detects a scanCompleted.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user wifi.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('wifi').\n\n"},"NONE":{"!type":"num","!doc":"\nConstant representing the NONE Authentication of the wifi.\n\n"},"WEP":{"!type":"num","!doc":"\nConstant representing the WEP Authentication of the wifi.\n\n"},"WPA_PSK":{"!type":"num","!doc":"\nConstant representing the WPA_PSK Authentication of the wifi.\n\n"},"CONNECTED":{"!type":"num","!doc":"\nConstant representing the CONNECTED State of the wifi.\n\n"},"DISCONNECTED":{"!type":"num","!doc":"\nConstant representing the DISCONNECTED State of the wifi.\n\n"}}},"_sting_definitions":{"_battery":{"!type":"battery"},"_form":{"!type":"form"},"_location":{"!type":"location"},"_log":{"!type":"log"},"_recorder":{"!type":"recorder"},"_timer":{"!type":"timer"},"_wifi":{"!type":"wifi"}},"!name":"APISENSELib"},{"!define":{"call":{"duration":{"!type":"fn() -> num","!doc":"\nReturn the current duration of the call.\n\n@return The call duration.\n\n"},"contact":{"!type":"fn() -> str","!doc":"\nReturn the current contact of the call.\n\n@return The call contact.\n\n"},"carrier":{"!type":"fn() -> str","!doc":"\nReturn the current carrier of the call.\n\n@return The call carrier.\n\n"},"neighbouringCells":{"!type":"fn() -> Arr","!doc":"\nReturn the current neighbouringCells of the call.\n\n@return The call neighbouringCells.\n\n"},"onCallEnded":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the call dart detects a callEnded.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user call.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('call').\n\n"}},"cpu":{"processor":{"!type":"fn() -> str","!doc":"\nReturn the current processor of the cpu.\n\n@return The cpu processor.\n\n"},"cpucores":{"!type":"fn() -> num","!doc":"\nReturn the current cpucores of the cpu.\n\n@return The cpu cpucores.\n\n"},"cpuimplementer":{"!type":"fn() -> str","!doc":"\nReturn the current cpuimplementer of the cpu.\n\n@return The cpu cpuimplementer.\n\n"},"cpuarchitecture":{"!type":"fn() -> num","!doc":"\nReturn the current cpuarchitecture of the cpu.\n\n@return The cpu cpuarchitecture.\n\n"},"cpuvariant":{"!type":"fn() -> str","!doc":"\nReturn the current cpuvariant of the cpu.\n\n@return The cpu cpuvariant.\n\n"},"cpupart":{"!type":"fn() -> str","!doc":"\nReturn the current cpupart of the cpu.\n\n@return The cpu cpupart.\n\n"},"cpurevision":{"!type":"fn() -> num","!doc":"\nReturn the current cpurevision of the cpu.\n\n@return The cpu cpurevision.\n\n"},"hardware":{"!type":"fn() -> str","!doc":"\nReturn the current hardware of the cpu.\n\n@return The cpu hardware.\n\n"},"revision":{"!type":"fn() -> num","!doc":"\nReturn the current revision of the cpu.\n\n@return The cpu revision.\n\n"},"serial":{"!type":"fn() -> str","!doc":"\nReturn the current serial of the cpu.\n\n@return The cpu serial.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user cpu.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('cpu').\n\n"}},"device":{"manufacturer":{"!type":"fn() -> str","!doc":"\nReturn the current manufacturer of the device.\n\n@return The device manufacturer.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the device.\n\n@return The device model.\n\n"},"os":{"!type":"fn() -> str","!doc":"\nReturn the current os of the device.\n\n@return The device os.\n\n"},"version":{"!type":"fn() -> str","!doc":"\nReturn the current version of the device.\n\n@return The device version.\n\n"},"screenSize":{"!type":"fn() -> num","!doc":"\nReturn the current screenSize of the device.\n\n@return The device screenSize.\n\n"},"resolution":{"!type":"fn() -> str","!doc":"\nReturn the current resolution of the device.\n\n@return The device resolution.\n\n"},"rotation":{"!type":"fn() -> num","!doc":"\nReturn the current rotation of the device.\n\n@return The device rotation.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user device.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('device').\n\n"}},"localStorage":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user localStorage.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"store":{"!type":"fn(toSave: JSON) -> num","!doc":"\nSave the given json in a local database.\n\n@param toSave A Json object to save.\n\n"},"timestamp":{"!type":"fn() -> num"},"entries":{"!type":"fn() -> str","!doc":"\nRetrieve every store object. This method returns the raw string representing a JSON Array, you may want to parse it with 'JSON.parse'\n\n"},"retrieve":{"!type":"fn(identifier: num) -> str","!doc":"\nRetrieve an object from the ID returned by the 'store' method. This method returns the raw string representing a JSON Object, you may want to parse it with 'JSON.parse'\n\n@param identifier ID of the entry to retrieve.\n\n"},"drop":{"!type":"fn()","!doc":"\nClear the store.\n\n"},"remove":{"!type":"fn(identifier: num)","!doc":"\nRemove an object from the ID returned by the 'store' method.\n\n@param identifier ID of the entry to remove.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('localStorage').\n\n"}},"memory":{"memtotal":{"!type":"fn() -> num","!doc":"\nReturn the current memtotal of the memory.\n\n@return The memory memtotal.\n\n"},"memfree":{"!type":"fn() -> num","!doc":"\nReturn the current memfree of the memory.\n\n@return The memory memfree.\n\n"},"buffers":{"!type":"fn() -> num","!doc":"\nReturn the current buffers of the memory.\n\n@return The memory buffers.\n\n"},"cached":{"!type":"fn() -> num","!doc":"\nReturn the current cached of the memory.\n\n@return The memory cached.\n\n"},"swapcached":{"!type":"fn() -> num","!doc":"\nReturn the current swapcached of the memory.\n\n@return The memory swapcached.\n\n"},"active":{"!type":"fn() -> num","!doc":"\nReturn the current active of the memory.\n\n@return The memory active.\n\n"},"inactive":{"!type":"fn() -> num","!doc":"\nReturn the current inactive of the memory.\n\n@return The memory inactive.\n\n"},"activeanon":{"!type":"fn() -> num","!doc":"\nReturn the current activeanon of the memory.\n\n@return The memory activeanon.\n\n"},"inactiveanon":{"!type":"fn() -> num","!doc":"\nReturn the current inactiveanon of the memory.\n\n@return The memory inactiveanon.\n\n"},"activefile":{"!type":"fn() -> num","!doc":"\nReturn the current activefile of the memory.\n\n@return The memory activefile.\n\n"},"inactivefile":{"!type":"fn() -> num","!doc":"\nReturn the current inactivefile of the memory.\n\n@return The memory inactivefile.\n\n"},"unevictable":{"!type":"fn() -> num","!doc":"\nReturn the current unevictable of the memory.\n\n@return The memory unevictable.\n\n"},"mlocked":{"!type":"fn() -> num","!doc":"\nReturn the current mlocked of the memory.\n\n@return The memory mlocked.\n\n"},"hightotal":{"!type":"fn() -> num","!doc":"\nReturn the current hightotal of the memory.\n\n@return The memory hightotal.\n\n"},"highfree":{"!type":"fn() -> num","!doc":"\nReturn the current highfree of the memory.\n\n@return The memory highfree.\n\n"},"lowtotal":{"!type":"fn() -> num","!doc":"\nReturn the current lowtotal of the memory.\n\n@return The memory lowtotal.\n\n"},"lowfree":{"!type":"fn() -> num","!doc":"\nReturn the current lowfree of the memory.\n\n@return The memory lowfree.\n\n"},"swaptotal":{"!type":"fn() -> num","!doc":"\nReturn the current swaptotal of the memory.\n\n@return The memory swaptotal.\n\n"},"swapfree":{"!type":"fn() -> num","!doc":"\nReturn the current swapfree of the memory.\n\n@return The memory swapfree.\n\n"},"dirty":{"!type":"fn() -> num","!doc":"\nReturn the current dirty of the memory.\n\n@return The memory dirty.\n\n"},"writeback":{"!type":"fn() -> num","!doc":"\nReturn the current writeback of the memory.\n\n@return The memory writeback.\n\n"},"anonpages":{"!type":"fn() -> num","!doc":"\nReturn the current anonpages of the memory.\n\n@return The memory anonpages.\n\n"},"mapped":{"!type":"fn() -> num","!doc":"\nReturn the current mapped of the memory.\n\n@return The memory mapped.\n\n"},"shmem":{"!type":"fn() -> num","!doc":"\nReturn the current shmem of the memory.\n\n@return The memory shmem.\n\n"},"slab":{"!type":"fn() -> num","!doc":"\nReturn the current slab of the memory.\n\n@return The memory slab.\n\n"},"sreclaimable":{"!type":"fn() -> num","!doc":"\nReturn the current sreclaimable of the memory.\n\n@return The memory sreclaimable.\n\n"},"sunreclaimable":{"!type":"fn() -> num","!doc":"\nReturn the current sunreclaimable of the memory.\n\n@return The memory sunreclaimable.\n\n"},"kernelstack":{"!type":"fn() -> num","!doc":"\nReturn the current kernelstack of the memory.\n\n@return The memory kernelstack.\n\n"},"pagetables":{"!type":"fn() -> num","!doc":"\nReturn the current pagetables of the memory.\n\n@return The memory pagetables.\n\n"},"nfsunstable":{"!type":"fn() -> num","!doc":"\nReturn the current nfsunstable of the memory.\n\n@return The memory nfsunstable.\n\n"},"bounce":{"!type":"fn() -> num","!doc":"\nReturn the current bounce of the memory.\n\n@return The memory bounce.\n\n"},"writebacktmp":{"!type":"fn() -> num","!doc":"\nReturn the current writebacktmp of the memory.\n\n@return The memory writebacktmp.\n\n"},"commitlimit":{"!type":"fn() -> num","!doc":"\nReturn the current commitlimit of the memory.\n\n@return The memory commitlimit.\n\n"},"committedas":{"!type":"fn() -> num","!doc":"\nReturn the current committedas of the memory.\n\n@return The memory committedas.\n\n"},"vmalloctotal":{"!type":"fn() -> num","!doc":"\nReturn the current vmalloctotal of the memory.\n\n@return The memory vmalloctotal.\n\n"},"vmallocused":{"!type":"fn() -> num","!doc":"\nReturn the current vmallocused of the memory.\n\n@return The memory vmallocused.\n\n"},"vmallocchunck":{"!type":"fn() -> num","!doc":"\nReturn the current vmallocchunck of the memory.\n\n@return The memory vmallocchunck.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user memory.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('memory').\n\n"}},"system":{"foreground":{"!type":"fn() -> str","!doc":"\nReturn the current foreground of the system.\n\n@return The system foreground.\n\n"},"services":{"!type":"fn() -> Arr","!doc":"\nReturn the current services of the system.\n\n@return The system services.\n\n"},"isScreen":{"!type":"fn(screen: num) -> bool","!doc":"\nTells if the current screen correspond to the asked screen.\n\n@param screen The screen to check.\n@return true if screens matches, false otherwise.\n\n"},"screen":{"!type":"fn() -> str","!doc":"\nReturn the current screen of the system.\n\n@return The system screen.\n\n"},"isLock":{"!type":"fn(lock: num) -> bool","!doc":"\nTells if the current lock correspond to the asked lock.\n\n@param lock The lock to check.\n@return true if locks matches, false otherwise.\n\n"},"lock":{"!type":"fn() -> str","!doc":"\nReturn the current lock of the system.\n\n@return The system lock.\n\n"},"onScreenUnlocked":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a screenUnlocked.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScreenStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a screenStateChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onForegroundAppChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the system dart detects a foregroundAppChanged.\n\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user system.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('system').\n\n"},"ON":{"!type":"num","!doc":"\nConstant representing the ON Screen of the system.\n\n"},"OFF":{"!type":"num","!doc":"\nConstant representing the OFF Screen of the system.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Screen of the system.\n\n"},"LOCKED":{"!type":"num","!doc":"\nConstant representing the LOCKED Lock of the system.\n\n"},"UNLOCKED":{"!type":"num","!doc":"\nConstant representing the UNLOCKED Lock of the system.\n\n"},"NOT_SECURED":{"!type":"num","!doc":"\nConstant representing the NOT_SECURED Lock of the system.\n\n"}}},"_sting_definitions":{"_call":{"!type":"call"},"_cpu":{"!type":"cpu"},"_device":{"!type":"device"},"_localStorage":{"!type":"localStorage"},"_memory":{"!type":"memory"},"_system":{"!type":"system"}},"!name":"APISENSE-Phone"},{"!define":{"accelerometer":{"x":{"!type":"fn() -> num","!doc":"\nReturn the current x of the accelerometer.\n\n@return The accelerometer x.\n\n"},"y":{"!type":"fn() -> num","!doc":"\nReturn the current y of the accelerometer.\n\n@return The accelerometer y.\n\n"},"z":{"!type":"fn() -> num","!doc":"\nReturn the current z of the accelerometer.\n\n@return The accelerometer z.\n\n"},"deltaX":{"!type":"fn() -> num","!doc":"\nReturn the current deltaX of the accelerometer.\n\n@return The accelerometer deltaX.\n\n"},"deltaY":{"!type":"fn() -> num","!doc":"\nReturn the current deltaY of the accelerometer.\n\n@return The accelerometer deltaY.\n\n"},"deltaZ":{"!type":"fn() -> num","!doc":"\nReturn the current deltaZ of the accelerometer.\n\n@return The accelerometer deltaZ.\n\n"},"minDelay":{"!type":"fn() -> num","!doc":"\nReturn the current minDelay of the accelerometer.\n\n@return The accelerometer minDelay.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the accelerometer.\n\n@return The accelerometer vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the accelerometer.\n\n@return The accelerometer model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the accelerometer.\n\n@return The accelerometer version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the accelerometer.\n\n@return The accelerometer accuracy.\n\n"},"onAccelerationDetected":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the accelerometer dart detects a accelerationDetected.\nProvided that the filters matches with the filters.\n\n@param filter The accelerometer configuration to set, can contain:\n- period (Integer): Time to wait between two captures in microseconds (default: 100 ms),\n- vector (Double): Minimal movement vector on the 3 axis summed (in m/s² - default: 9.81).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user accelerometer.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('accelerometer').\n\n"}},"gravity":{"x":{"!type":"fn() -> num","!doc":"\nReturn the current x of the gravity.\n\n@return The gravity x.\n\n"},"y":{"!type":"fn() -> num","!doc":"\nReturn the current y of the gravity.\n\n@return The gravity y.\n\n"},"z":{"!type":"fn() -> num","!doc":"\nReturn the current z of the gravity.\n\n@return The gravity z.\n\n"},"isPosition":{"!type":"fn(position: num) -> bool","!doc":"\nTells if the current position correspond to the asked position.\n\n@param position The position to check.\n@return true if positions matches, false otherwise.\n\n"},"position":{"!type":"fn() -> str","!doc":"\nReturn the current position of the gravity.\n\n@return The gravity position.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the gravity.\n\n@return The gravity vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the gravity.\n\n@return The gravity model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the gravity.\n\n@return The gravity version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the gravity.\n\n@return The gravity accuracy.\n\n"},"onPositionChanged":{"!type":"fn(period: num, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the gravity dart detects a positionChanged.\nProvided that the filters matches with the filters.\n\n@param period Time to wait between two captures in microseconds (default: 100 ms).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user gravity.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('gravity').\n\n"},"BACK":{"!type":"num","!doc":"\nConstant representing the BACK Position of the gravity.\n\n"},"SCREEN":{"!type":"num","!doc":"\nConstant representing the SCREEN Position of the gravity.\n\n"},"UP_SIDE":{"!type":"num","!doc":"\nConstant representing the UP_SIDE Position of the gravity.\n\n"},"DOWN_SIDE":{"!type":"num","!doc":"\nConstant representing the DOWN_SIDE Position of the gravity.\n\n"},"LEFT_SIDE":{"!type":"num","!doc":"\nConstant representing the LEFT_SIDE Position of the gravity.\n\n"},"RIGHT_SIDE":{"!type":"num","!doc":"\nConstant representing the RIGHT_SIDE Position of the gravity.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Position of the gravity.\n\n"}},"gyroscope":{"x":{"!type":"fn() -> num","!doc":"\nReturn the current x of the gyroscope.\n\n@return The gyroscope x.\n\n"},"y":{"!type":"fn() -> num","!doc":"\nReturn the current y of the gyroscope.\n\n@return The gyroscope y.\n\n"},"z":{"!type":"fn() -> num","!doc":"\nReturn the current z of the gyroscope.\n\n@return The gyroscope z.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the gyroscope.\n\n@return The gyroscope vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the gyroscope.\n\n@return The gyroscope model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the gyroscope.\n\n@return The gyroscope version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the gyroscope.\n\n@return The gyroscope accuracy.\n\n"},"onRotationDetected":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the gyroscope dart detects a rotationDetected.\nProvided that the filters matches with the filters.\n\n@param filter The gyroscope configuration to set, can contain:\n- period (Integer): Time to wait between two captures in microseconds (default: 100 ms),\n- speed (Double): Minimal movement vector on the 3 axis summed (in rad/s² - default: 3).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user gyroscope.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('gyroscope').\n\n"}},"rotation":{"x":{"!type":"fn() -> num","!doc":"\nReturn the current x of the rotation.\n\n@return The rotation x.\n\n"},"y":{"!type":"fn() -> num","!doc":"\nReturn the current y of the rotation.\n\n@return The rotation y.\n\n"},"z":{"!type":"fn() -> num","!doc":"\nReturn the current z of the rotation.\n\n@return The rotation z.\n\n"},"scalarComponent":{"!type":"fn() -> num","!doc":"\nReturn the current scalarComponent of the rotation.\n\n@return The rotation scalarComponent.\n\n"},"scalarComponentDelta":{"!type":"fn() -> num","!doc":"\nReturn the current scalarComponentDelta of the rotation.\n\n@return The rotation scalarComponentDelta.\n\n"},"rotationMatrix":{"!type":"fn() -> Arr","!doc":"\nReturn the current rotationMatrix of the rotation.\n\n@return The rotation rotationMatrix.\n\n"},"azimuth":{"!type":"fn() -> num","!doc":"\nReturn the current azimuth of the rotation.\n\n@return The rotation azimuth.\n\n"},"pitch":{"!type":"fn() -> num","!doc":"\nReturn the current pitch of the rotation.\n\n@return The rotation pitch.\n\n"},"roll":{"!type":"fn() -> num","!doc":"\nReturn the current roll of the rotation.\n\n@return The rotation roll.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the rotation.\n\n@return The rotation vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the rotation.\n\n@return The rotation model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the rotation.\n\n@return The rotation version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the rotation.\n\n@return The rotation accuracy.\n\n"},"onRotationDetected":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the rotation dart detects a rotationDetected.\nProvided that the filters matches with the filters.\n\n@param filter The rotation configuration to set, can contain:\n- period (Integer): Time to wait between two captures in microseconds (default: 100 ms),\n- rotation (Double): Minimal scalar component delta to trigger the event (range: [0, 1] - default: 0.5).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user rotation.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('rotation').\n\n"}}},"_sting_definitions":{"_accelerometer":{"!type":"accelerometer"},"_gravity":{"!type":"gravity"},"_gyroscope":{"!type":"gyroscope"},"_rotation":{"!type":"rotation"}},"!name":"APISENSE-Motion"},{"!define":{"light":{"luminosity":{"!type":"fn() -> num","!doc":"\nReturn the current luminosity of the light.\n\n@return The light luminosity.\n\n"},"luminosityDelta":{"!type":"fn() -> num","!doc":"\nReturn the current luminosityDelta of the light.\n\n@return The light luminosityDelta.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the light.\n\n@return The light vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the light.\n\n@return The light model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the light.\n\n@return The light version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the light.\n\n@return The light accuracy.\n\n"},"onLuminosityDetected":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the light dart detects a luminosityDetected.\nProvided that the filters matches with the filters.\n\n@param filter The light configuration to set, can contain:\n- period (Integer): Time to wait between two captures in microseconds (default: 100 ms),\n- above (Double): Minimal luminosity to trigger the event (default: 0 lx),\n- under (Double): Maximum luminosity to trigger the event (default: infinity),\n- delta (Double): Minimal luminosity change to trigger the event (default: 200 lx).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user light.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('light').\n\n"}},"pressure":{"pressure":{"!type":"fn() -> num","!doc":"\nReturn the current pressure of the pressure.\n\n@return The pressure pressure.\n\n"},"pressureDelta":{"!type":"fn() -> num","!doc":"\nReturn the current pressureDelta of the pressure.\n\n@return The pressure pressureDelta.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the pressure.\n\n@return The pressure vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the pressure.\n\n@return The pressure model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the pressure.\n\n@return The pressure version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the pressure.\n\n@return The pressure accuracy.\n\n"},"onPressureChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the pressure dart detects a pressureChanged.\nProvided that the filters matches with the filters.\n\n@param filter The pressure configuration to set, can contain:\n- period (Integer): Time to wait between two captures in microseconds (default: 100 ms),\n- above (Double): Minimal pressure to trigger the event (default: 0 hPa),\n- under (Double): Maximum pressure to trigger the event (default: infinity),\n- delta (Double): Minimal pressure change to trigger the event (default: 200 hPa).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user pressure.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('pressure').\n\n"}},"proximity":{"isDistance":{"!type":"fn(distance: num) -> bool","!doc":"\nTells if the current distance correspond to the asked distance.\n\n@param distance The distance to check.\n@return true if distances matches, false otherwise.\n\n"},"distance":{"!type":"fn() -> str","!doc":"\nReturn the current distance of the proximity.\n\n@return The proximity distance.\n\n"},"vendor":{"!type":"fn() -> str","!doc":"\nReturn the current vendor of the proximity.\n\n@return The proximity vendor.\n\n"},"model":{"!type":"fn() -> str","!doc":"\nReturn the current model of the proximity.\n\n@return The proximity model.\n\n"},"version":{"!type":"fn() -> num","!doc":"\nReturn the current version of the proximity.\n\n@return The proximity version.\n\n"},"accuracy":{"!type":"fn() -> SensorAccuracy","!doc":"\nReturn the current accuracy of the proximity.\n\n@return The proximity accuracy.\n\n"},"onDistanceChanged":{"!type":"fn(period: num, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the proximity dart detects a distanceChanged.\nProvided that the filters matches with the filters.\n\n@param period Time to wait between two captures in microseconds (default: 100 ms).\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user proximity.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('proximity').\n\n"},"CLOSE":{"!type":"num","!doc":"\nConstant representing the CLOSE Distance of the proximity.\n\n"},"FAR":{"!type":"num","!doc":"\nConstant representing the FAR Distance of the proximity.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN Distance of the proximity.\n\n"}}},"_sting_definitions":{"_light":{"!type":"light"},"_pressure":{"!type":"pressure"},"_proximity":{"!type":"proximity"}},"!name":"APISENSE-Motion"},{"!define":{"visualization":{"map":{"!type":"fn(arg0: num) -> Data"},"stop":{"!type":"fn()"},"!doc":"\nRetrieve data about the user visualization.\n\n","available":{"!type":"fn(arg0: num) -> bool"},"seeds":{"!type":"fn() -> num"},"data":{"!type":"fn() -> Data"},"addBarChart":{"!type":"fn(title: str, initCallback: fn(JSON)) -> IVisualization","!doc":"\nAdds new bar chart visualization\n\n@param title Title of chart\n@param initCallback Function called during chart widget initialization, receives two parameters (chart, data), a Chart instance to set the data and a list of the stored data\n\n"},"addLineChart":{"!type":"fn(title: str, initCallback: fn(JSON)) -> IVisualization","!doc":"\nAdds new line chart visualization\n\n@param title Title of chart\n@param initCallback Function called during chart widget initialization, receives two parameters (chart, data), a Chart instance to set the data and a list of the stored data\n\n"},"addMap":{"!type":"fn(title: str, initCallback: fn(JSON)) -> IVisualization","!doc":"\nAdds new map\n\n@param title Title of map\n@param initCallback Function called during map widget initialization, receives two parameters (map, data), a Map instance to set the data and a list of the stored data\n\n"},"addPieChart":{"!type":"fn(title: str, initCallback: fn(JSON)) -> IVisualization","!doc":"\nAdds new pie chart visualization\n\n@param title Title of chart\n@param initCallback Function called during chart widget initialization, receives two parameters (chart, data), a Chart instance to set the data and a list of the stored data\n\n"},"timestamp":{"!type":"fn() -> num"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('visualization').\n\n"}}},"_sting_definitions":{"_visualization":{"!type":"visualization"}},"!name":"APISENSE-Visualization"}]