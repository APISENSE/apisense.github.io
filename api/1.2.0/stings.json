{"!define":{"apm":{"!doc":"\nMeasure network performances such as latency, download and upload bandwidth.\n\n","onDownloadCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nGET the given url and give data about network performances,\n(size, speed, data).\n\n@param url The url to access.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onScanCompleted":{"!type":"fn(url: str, callback: fn(JSON)) -> Token","!doc":"\nCreate a traceroute on the given URL.\n\n@param url The url to scan.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"onUploadCompleted":{"!type":"fn(protocol: str, host: str, username: str, password: str, size: num, callback: fn(JSON)) -> Token","!doc":"\nUpload a dummy file to the given FTP server and give data about network performances,\n(size, speed, data).\n\n@param protocol The protocol to use (FTP{,s}).\n@param host The host name or IP to contact.\n@param username The username if any.\n@param password The password if any.\n@param size The size of the file to upload.\n@param callback The action to process when done.\n@return The cancellation Token.\n\n"},"ttl":{"!type":"fn() -> num","!doc":"\nReturn the last found TTL.\n\n@return The ttl value.\n\n"},"ping":{"!type":"fn() -> num","!doc":"\nReturn the last ping\n\n@return The ping value in ms.\n\n"},"url":{"!type":"fn() -> str","!doc":"\nReturn the asked URL.\n\n@return The url String.\n\n"},"traceroute":{"!type":"fn() -> Arr","!doc":"\nReturn the last traceroute data.\n\n@return The list of Hop in the traceroute.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('apm').\n\n"}},"battery":{"!doc":"\nRetrieve data about the battery state & usage.\n\n","isConnector":{"!type":"fn(connector: num) -> bool","!doc":"\nTells if the current connection status correspond to the asked connector.\n\n@param connector The connector to check.\n@return true if connection matches, false otherwise.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"onLevelChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery level change.\n\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the battery state is modified.\n\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"level":{"!type":"fn() -> num","!doc":"\nReturn the current battery level.\n\n@return The battery level.\n\n"},"temperature":{"!type":"fn() -> num","!doc":"\nReturn the temperature of the battery.\n\n@return The temperature.\n\n"},"voltage":{"!type":"fn() -> num","!doc":"\nReturn the current feed of the battery.\n\n@return The voltage.\n\n"},"connector":{"!type":"fn() -> str","!doc":"\nReturn the current connection status of the battery.\n\n@return The string representation of the used connector.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the battery.\n\n@return The string representation of the state.\n\n"},"technology":{"!type":"fn() -> str","!doc":"\nReturn the thechnology used by the battery.\n\n@return The technology name.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('battery').\n\n"},"FULL":{"!type":"num","!doc":"\nConstant representing the FULL state of the battery.\n\n"},"CHARGING":{"!type":"num","!doc":"\nConstant representing the CHARGING state of the battery.\n\n"},"DISCHARGING":{"!type":"num","!doc":"\nConstant representing the DISCHARGING state of the battery.\n\n"},"AC":{"!type":"num","!doc":"\nConstant representing the AC connection of the battery.\n\n"},"USB":{"!type":"num","!doc":"\nConstant representing the USB connection of the battery.\n\n"},"WIRELESS":{"!type":"num","!doc":"\nConstant representing the WIRELESS connection of the battery.\n\n"},"NOT_CONNECTED":{"!type":"num","!doc":"\nConstant representing the NOT_CONNECTED connection of the battery.\n\n"}},"location":{"!doc":"\nRetrieve data about the user location and mouvement.\n\n","isMode":{"!type":"fn(mode: num) -> bool","!doc":"\nTells if the current mode correspond to the asked mode.\n\n@param mode The mode to check.\n@return true if modes matches, false otherwise.\n\n"},"isSource":{"!type":"fn(source: num) -> bool","!doc":"\nTells if the current source correspond to the asked source.\n\n@param source The source to check.\n@return true if sources matches, false otherwise.\n\n"},"onLocationChanged":{"!type":"fn(filter: JSON, callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the GPS detect another location,\nprovided that the filters matches with the new location.\n\n@param filter The GPS configuration to set, can contain:\n- The GPS \"mode\" (PASSIVE by default),\n- The minimal \"distance\" in meters between two triggered locations (50 meters by default).\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"accuracy":{"!type":"fn() -> num","!doc":"\nReturn the last location's accuracy.\n\n@return The accuracy value.\n\n"},"altitude":{"!type":"fn() -> num","!doc":"\nReturn the last location's altitude.\n\n@return The altitude value.\n\n"},"bearing":{"!type":"fn() -> num","!doc":"\nReturn the last location's bearing.\n\n@return The bearing value.\n\n"},"latitude":{"!type":"fn() -> num","!doc":"\nReturn the last location's latitude.\n\n@return The latitude value.\n\n"},"longitude":{"!type":"fn() -> num","!doc":"\nReturn the last location's longitude.\n\n@return The longitude value.\n\n"},"speed":{"!type":"fn() -> num","!doc":"\nReturn the last location's speed.\n\n@return The speed value.\n\n"},"mode":{"!type":"fn() -> str","!doc":"\nReturn the currently used GPS mode.\n\n@return The mode's String representation.\n\n"},"source":{"!type":"fn() -> str","!doc":"\nReturn the currently used GPS source.\n\n@return The source's String representation.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('location').\n\n"},"ACTIVE":{"!type":"num","!doc":"\nConstant representing the ACTIVE mode of the GPS.\n\n"},"PASSIVE":{"!type":"num","!doc":"\nConstant representing the PASSIVE mode of the GPS.\n\n"},"UNKNOWN":{"!type":"num","!doc":"\nConstant representing the UNKNOWN source of the GPS.\n\n"},"GPS":{"!type":"num","!doc":"\nConstant representing the GPS source of the GPS.\n\n"},"NETWORK":{"!type":"num","!doc":"\nConstant representing the NETWORK source of the GPS.\n\n"}},"wifi":{"!doc":"\nRetrieve data about the WIFI connection and scan available networks.\n\n","isAuthentication":{"!type":"fn(authentication: num) -> bool","!doc":"\nTells if the current security level correspond to the asked state.\n\n@param authentication The security level to check.\n@return true if security levels matches, false otherwise.\n\n"},"isState":{"!type":"fn(state: num) -> bool","!doc":"\nTells if the current state correspond to the asked state.\n\n@param state The state to check.\n@return true if states matches, false otherwise.\n\n"},"onScanCompleted":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the available WIFI networks scan is done.\n\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"onSsidChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the WIFI network SSID changes.\n\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"onStateChanged":{"!type":"fn(callback: fn(JSON)) -> Token","!doc":"\nExecute the callback when the WIFI interface state changes.\n\n@param callback The action to process.\n@return The cancellation Token.\n\n"},"frequency":{"!type":"fn() -> num","!doc":"\nReturn the current frequency of the WIFI network.\n\n@return The frequency of the network.\n\n"},"rssi":{"!type":"fn() -> num","!doc":"\nReturn the current RSSI of the WIFI network.\n\n@return The RSSI of the network.\n\n"},"authentication":{"!type":"fn() -> str","!doc":"\nReturn the current security level of the WIFI network.\n\n@return The security level's String representation.\n\n"},"bssid":{"!type":"fn() -> str","!doc":"\nReturn the current BSSID of the WIFI network.\n\n@return The BSSID of the network.\n\n"},"ssid":{"!type":"fn() -> str","!doc":"\nReturn the current SSID of the WIFI network.\n\n@return The SSID of the network.\n\n"},"state":{"!type":"fn() -> str","!doc":"\nReturn the current state of the WIFI interface.\n\n@return The state's String representation.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('wifi').\n\n"},"CONNECTED":{"!type":"num","!doc":"\nConstant representing the CONNECTED state of the WIFI interface.\n\n"},"DISCONNECTED":{"!type":"num","!doc":"\nConstant representing the DISCONNECTED state of the WIFI interface.\n\n"},"WEP":{"!type":"num","!doc":"\nConstant representing the WEP security level on a WIFI network.\n\n"},"WPA_PSK":{"!type":"num","!doc":"\nConstant representing the WPA_PSK security level on a WIFI network.\n\n"}},"log":{"!doc":"\nEnables to print some data on the device log interface.\n\n","debug":{"!type":"fn(message: str)","!doc":"\nPrint a debug message.\n\n@param message The String to print.\n\n"},"error":{"!type":"fn(message: str)","!doc":"\nPrint an error message.\n\n@param message The String to print.\n\n"},"info":{"!type":"fn(message: str)","!doc":"\nPrint an info message.\n\n@param message The String to print.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('log').\n\n"}},"recorder":{"!doc":"\nEnables to save collected data and send them to a central server.\n\n","save":{"!type":"fn(jsonBody: fn(JSON))","!doc":"\nSave a JSON of data locally.\n\n@param jsonBody The data to save, can be:\n- in JSON format,\n- A raw object, in this case its fields will be serialized as a JSON.\n\n"},"sync":{"!type":"fn(jsonHeader: JSON)","!doc":"\nSend every saved data to the central server with some metadata.\n\n@param jsonHeader Some metadata to add on the sent bloc.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('recorder').\n\n"}},"timer":{"!doc":"\nEnables to create events triggered by time.\n\n","at":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nTrigger every day at the specified hour of the day,\nThe time is in 12h notation e.g. \"3:15 PM\"\n\n@param time The time at which the event must be triggered each day.\n@param callback The action to process when the event is triggered.\n@return The cancellation Token.\n\n"},"every":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nTrigger an event periodically.\n\n@param time The time to wait between each event call (e.g. \"10h\").\n@param callback The action to process when the event is triggered.\n@return The cancellation Token.\n\n"},"once":{"!type":"fn(time: str, callback: fn(JSON)) -> Token","!doc":"\nTrigger every day at the specified hour, one time only\nThe time is in 12h notation e.g. \"3:15 PM\"\n\n@param time The time at which the event must be triggered.\n@param callback The action to process when the event is triggered.\n@return The cancellation Token.\n\n"},"NAME":{"!type":"str","!doc":"\nidentifier of the sting to be used as require('timer').\n\n"}}},"_sting_definitions":{"_apm":{"!type":"apm"},"_battery":{"!type":"battery"},"_location":{"!type":"location"},"_wifi":{"!type":"wifi"},"_log":{"!type":"log"},"_recorder":{"!type":"recorder"},"_timer":{"!type":"timer"}},"!name":"APISENSELib"}